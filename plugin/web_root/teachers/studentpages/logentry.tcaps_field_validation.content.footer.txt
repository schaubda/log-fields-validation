<!--NoLink-->
<!-- Begin TCAPS Log Fields Validation Plugin -->
<script type="text/javascript">
    /**
     * CSS selectors for form fields that require validation.
     * Used to attach event handlers and perform validation checks.
     * Fields included:
     *   - #discipline_incidentdate: Incident date input
     *   - #discipline_incidenttime_disp: Incident time input
     *   - #entry: Log entry text input
     *   - #discipline_incidentlocation: Incident location input
     *   - #subtype: Incident Subtype input
     * @type {string}
     */
    const VALIDATION_FIELDS =
              '#discipline_incidentdate, #discipline_incidenttime_disp, #entry, ' +
              '#discipline_incidentlocation, select[name="subtype"]';

    /**
     * On DOM ready, removes the table row containing the Title field input
     * and sets up a MutationObserver to handle dynamic changes in the form table.
     */
    $j(function ()
       {
           $j('#subject').closest('tr').remove();

           setupMutationObserver();
       });

    /**
     * Sets up a MutationObserver on the '.fourDTable tbody' element
     * to watch for child node changes and invoke the mutation handler.
     */
    function setupMutationObserver()
    {
        const targetNode = document.querySelector('.fourDTable tbody');
        const config = {childList: true, subtree: true};

        const observer = new MutationObserver(mutationHandler);
        observer.observe(targetNode, config);
    }

    /**
     * Handles mutations observed in the form table.
     * Iterates through the list of mutations and, when a row containing
     * the `#discipline_incidentlocation` field is added, performs the following:
     *   - Restripes the table rows for visual consistency.
     *   - Fixes the label for the incident location field.
     *   - Attaches change event handlers to validation fields.
     *   - Attaches a click handler to the submit button for form validation.
     *   - Disconnects the observer to prevent repeated handling.
     *
     * @param {MutationRecord[]} mutationsList - List of mutations observed.
     * @param {MutationObserver} observer - The observer instance.
     */
    function mutationHandler(mutationsList, observer)
    {
        mutationsList.forEach(
            function (mutation)
            {
                if (mutation.type === 'childList' &&
                    $j(mutation.addedNodes).is('#discipline_incidentlocation'))
                {
                    restripeTable();
                    fixIncidentLocationLabel();
                    $j(VALIDATION_FIELDS).on('change', fieldChange);
                    $j('button[type="submit"]').click(validateFormFields);
                    observer.disconnect();
                }
            });
    }

    /**
     * Applies alternating 'alt' class to table rows for visual striping.
     * Skips the first two and the last row of the table.
     * Removes any existing 'alt' class, then adds it to even-indexed rows.
     */
    function restripeTable()
    {
        let formTable = $j('.fourDTable tbody tr')
            .slice(2, $j('.fourDTable tbody tr').size() - 1);

        formTable.removeClass('alt');

        formTable.each(function (index)
                       {
                           if (index % 2 === 0)
                           {
                               $j(this).addClass('alt');
                           }
                       });
    }

    /**
     * Fixes the label for the incident location field.
     * Finds the label associated with the `#discipline_incidentlocation` input,
     * and trims its HTML content to end at the closing </font> tag.
     * This is used to remove the extra garbage characters left over in the
     * database from a previous plugin.
     */
    function fixIncidentLocationLabel()
    {
        let incidentLocationLabel =
                $j('#discipline_incidentlocation').closest('tr').find('label');
        let newHtml = incidentLocationLabel.html().replace(/<\/font>.*/, '</font>');

        incidentLocationLabel.html(newHtml);
    }

    /**
     * Handles the change event for validation fields.
     * If the field is empty or contains only whitespace, highlights it with a pink background.
     * Otherwise, removes the background highlight.
     */
    function fieldChange()
    {
        if (!$j(this).val() || $j(this).val().trim() === '')
        {
            $j(this).css("background-color", "pink");
        }
        else
        {
            if ($j(this).attr('id') === 'discipline_incidenttime_disp'
                && !validateIncidentTime())
            {
                $j(this).css("background-color", "pink");
            }
            else
            {
                $j(this).css("background-color", "");
            }
        }
    }

    /**
     * Validates required form fields before submission.
     *
     * Iterates over all fields specified in VALIDATION_FIELDS (except for the subtype field),
     * checking if they are empty or contain only whitespace. If a field is invalid:
     *   - Sets the valid flag to false.
     *   - Attempts to retrieve the field's label text for reporting.
     *   - If the label is missing, defaults to 'Incident Time'.
     *   - Appends the label to the invalidFields string for display.
     *   - Highlights the invalid field with a pink background and focuses it.
     *
     * If any required fields are invalid and the subtype field is filled,
     * displays an alert listing the missing fields.
     *
     * @returns {boolean} true if all required fields are valid, false otherwise.
     */
    function validateFormFields()
    {
        let valid = true;
        let invalidFields = '';
        let validationFields = $j(VALIDATION_FIELDS).not('select[name="subtype"]');

        if ($j('#logtype').val() !== -100000)
        {
            validationFields = validationFields
                .not('#discipline_incidenttime_disp, #discipline_incidentlocation');
        }

        validationFields.each(
            function (index, element)
            {
                if (!$j(element).val() || $j(element).val().trim() === '')
                {
                    valid = false;

                    let labelText = $j("label[for='" + $j(element).attr('id') + "']").text();

                    if (labelText === '')
                    {
                        labelText = 'Incident Time';
                    }

                    invalidFields += labelText.replace(/\s\[.*/g, '').trim() + ',<br/>';

                    $j(element).css("background-color", "pink").focus();
                }
            });

        if (!valid && invalidFields !== '' && $j('select[name="subtype"]').val())
        {
            invalidFields = invalidFields.replace(/,<br\/>$/g, '');

            psAlert({
                        message: `The following fields must be entered:<br/>${invalidFields}`,
                        title:   'WARNING'
                    });
        }
        else if ($j('select[name="subtype"]').val() && $j('#logtype').val() === -100000)
        {
            valid = validateIncidentTime();

            if (!valid)
            {
                psAlert({
                            message: 'The incident time must be between 5:00 AM and 11:59 PM',
                            title:   'WARNING'
                        });

                $j('#discipline_incidenttime_disp').css("background-color", "pink").focus();
            }
        }

        return valid;
    }

    function validateIncidentTime()
    {
        // Convert the input time from 12-hour to 24-hour format and split into hours and minutes
        let [incidentHours, incidentMinutes] =
                convertTime12to24($j('#discipline_incidenttime_disp').val()).split(':');

        // Create a Date object for the incident time and set its hours and minutes
        let incidentTime = new Date();
        incidentTime.setHours(parseInt(incidentHours), parseInt(incidentMinutes), 0, 0);

        // Create a Date object representing the minimum allowed time (5:00 AM)
        let minTime = new Date();
        minTime.setHours(5, 0, 0, 0);

        // Create a Date object representing the maximum allowed time (11:59 PM)
        let maxTime = new Date();
        maxTime.setHours(23, 59, 59, 0);

        // Check if the incident time is outside the allowed range
        return incidentTime >= minTime && incidentTime <= maxTime;
    }

    /**
     * Converts a 12-hour time string (e.g., "01:30 PM") to 24-hour format (e.g., "13:30").
     * Used for validating incident times.
     * @param {string} time12h - The time string in 12-hour format.
     * @returns {string} The time in 24-hour format.
     */
    function convertTime12to24(time12h)
    {
        // Split the 12-hour time string into time and AM/PM modifier
        let [time, modifier] = time12h.split(' ');

        // Split the time into hours and minutes
        let [hours, minutes] = time.split(':');

        // If the hour is 12, set it to 00 (midnight or noon will be handled by modifier)
        if (hours === '12')
        {
            hours = '00';
        }

        // If the modifier is PM, add 12 to the hours to convert to 24-hour format
        if (modifier === 'PM')
        {
            hours = parseInt(hours, 10) + 12;
        }

        // Return the time in 24-hour format as a string
        return `${hours}:${minutes}`;
    }
</script>
<!-- End TCAPS Log Fields Validation Plugin -->